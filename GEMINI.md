# Gemini 텔레그램 봇 프로젝트 분석

## 1. 프로젝트 목적

이 프로젝트는 Google의 최신 Gemini AI 모델을 활용하여 사용자의 다양한 요구사항을 처리하는 다기능 텔레그램 봇입니다. 텍스트 기반의 대화는 물론, 시각적 정보(이미지)를 이해하고 생성하며, 웹 검색 및 코드 실행과 같은 강력한 도구를 결합하여 사용자에게 지능적인 비서 경험을 제공합니다. 특히 대화의 맥락(Context)을 기억하는 세션 관리 시스템을 통해 단순한 단발성 응답을 넘어선 깊이 있는 상호작용이 가능하며, 클래스 기반 아키텍처를 통해 높은 확장성과 유지보수성을 확보하고 있습니다.

## 2. 주요 기능

- **명령어 동적 관리 및 자동 등록:** 봇 시작 시 `CommandDispatcher`에 등록된 모든 명령어를 분석하여 텔레그램 공식 메뉴에 자동으로 설정합니다. 별칭(Alias) 지원을 통해 사용자 편의성을 높였으며, 공식 목록 노출 여부를 개별적으로 제어할 수 있습니다.
- **지능형 명령어 라우팅:** 그룹 채팅 환경에서 `/명령어@봇이름` 형식을 정확히 인식하여 자신의 사용자명과 일치할 때만 응답함으로써 다른 봇과의 혼선을 방지합니다. 명시적 명령어 외에도 봇의 메시지에 대한 '답장'을 통해 문맥을 이어가는 암시적 명령어 처리 기능을 포함합니다.
- **텍스트 생성 및 멀티모달 대화:** 최신 Gemini 3.0 Pro 모델을 통해 텍스트 응답을 생성합니다. 사용자가 전송한 이미지나 텍스트 파일(PDF, TXT, 소스 코드 등)을 이해하고 이를 대화의 맥락으로 활용합니다. (`/gemini`, `/g` 별칭)
- **고해상도 이미지 생성:** 사용자의 상세 묘사를 기반으로 고품질 이미지를 생성합니다. `1k`, `2k`, `4k`와 같은 해상도 파라미터를 지원하여 용도에 맞는 결과물을 얻을 수 있습니다. (`/image`, `/img` 별칭)
- **지도 기반 지능형 안내:** Google 지도 도구가 활성화된 상태로 AI와 대화하여, 위치 정보나 경로 안내 등에 특화된 답변을 제공받을 수 있습니다. (`/map` 명령어)
- **GeekNews 스타일 콘텐츠 요약:** 특정 시스템 프롬프트를 사용하여 복잡한 기사나 긴 텍스트를 고밀도의 'GeekNews(Hada.io)' 스타일 명사형 종결 문체로 요약합니다. (`/summarize` 명령어)
- **연속적인 대화 맥락 유지:** 봇의 메시지에 답장하는 방식(Reply)이나 이전 대화의 흐름을 SQLite 데이터베이스에 기록된 기록을 바탕으로 세션화하여 자연스러운 대화를 이어갑니다. 최대 15단계의 대화 이력을 추적하여 일관성 있는 답변을 제공합니다.
- **미디어 그룹 처리 (Album):** 한 번에 전송된 여러 장의 사진(앨범)을 개별 요청이 아닌 하나의 그룹화된 요청으로 인식하여 500ms 내에 통합 처리합니다.
- **안정적인 인프라 및 보안:** SQLite 기반의 영구 저장소를 사용하여 대화 기록 및 메타데이터의 무결성을 보장하며, 환경 변수에 정의된 신뢰할 수 있는 사용자만 봇을 이용할 수 있도록 인증 체계를 갖추고 있습니다.

## 3. 사용된 주요 기술

- **언어 및 런타임:** TypeScript (v5+), Node.js (Latest LTS)
- **메시징 API:** `node-telegram-bot-api`
- **Generative AI:** `@google/genai` (Google AI SDK v0.x)
- **데이터 저장소:** `sqlite3` (로컬 파일 베이스 DB)
- **마크다운 지원:** `marked` (응답 텍스트의 HTML 파싱 및 렌더링)
- **테스트:** `Jest` (단위 및 통합 테스트)
- **설정 관리:** `dotenv` (안전한 환경 변수 로드)

## 4. 프로젝트 구조

```
.
├── src/                      # 소스 코드 디렉토리
│   ├── bot.ts                # 봇의 메인 진입점 및 메시지 인터셉터
│   ├── config.ts             # 환경 변수 로드 및 전역 설정 관리
│   ├── types.ts              # 프로젝트 전역 타입 및 인터페이스 정의
│   ├── managers/             # 중앙 통제 및 상태 관리 계층 (Managers)
│   │   ├── CommandDispatcher.ts  # 명령어 식별, 인수 파싱 및 실행 위임
│   │   ├── SessionManager.ts     # DB 기반 대화 세션 구성 및 리트리브
│   │   └── CommandRegistry.ts    # 명령어 등록 및 조회 인터페이스
│   ├── commands/             # 개별 비즈니스 로직 (명령어 클래스)
│   │   ├── BaseCommand.ts        # 모든 명령어의 공통 인터페이스 (회신 로직 포함)
│   │   ├── GenAICommand.ts       # AI 연동 공통 로직 (재시도, 안전성 검사, 포맷팅)
│   │   ├── ChatCommand.ts        # /gemini: 일반 텍스트 대화 처리
│   │   ├── ImageCommand.ts       # /image: 이미지 생성 및 해상도 제어
│   │   ├── MapCommand.ts         # /map: 지도 도구 결합 대화
│   │   ├── SummarizeCommand.ts   # /summarize: 고밀도 정보 요약
│   │   ├── StartCommand.ts       # /start: 환영 메시지 및 초기 안내
│   │   └── HelpCommand.ts        # /help: 동적 도움말 생성 및 상세 가이드
│   ├── services/             # 인프라 서비스 (영구 저장 및 인증)
│   │   ├── db.ts                # SQLite 연결, 테이블 관리 및 재귀적 기록 조회
│   │   └── auth.ts              # 화이트리스트 기반 사용자 권한 검증
│   └── helpers/              # 유틸리티 및 보조 기능
│       └── utils.ts             # 파일 버퍼 처리, 스트림 변환 등 공통 유틸리티
├── tests/                    # Jest 테스트 스위트
│   ├── commands/             # 명령어 클래스별 단위 테스트
│   ├── managers/             # 매니저 로직 테스트
│   └── services/             # DB 및 인증 서비스 테스트
├── docs/                     # 프로젝트 문서 관리
├── package.json              # 의존성 및 스크립트 설정
└── tsconfig.json             # TypeScript 컴파일러 설정
```

## 5. 핵심 모듈 상세 분석

### 5.1. 매니저 계층 (Managers)

- **`CommandDispatcher`**: 봇의 '중앙 역무원' 역할을 수행합니다. 사용자가 입력한 메시지가 명시적 명령어인지, 아니면 봇의 이전 메시지에 대한 답변(암시적 명령어)인지를 판별합니다. 또한 명령어 뒤에 따라오는 인자(Parameter)를 정의된 규칙에 따라 자동으로 추출하여 실행 컨텍스트(`CommandContext`)를 구성합니다. 모든 명령어의 실행 전 `validate` 단계를 거쳐 비정상적인 요청을 사전에 차단합니다. 앨범 메시지 처리를 위해 500ms의 윈도우 타이머를 운영하여 분산된 메시지를 하나의 컨텍스트로 통합합니다.
- **`SessionManager`**: 무상태(Stateless)인 AI API 호출을 유상태(Stateful) 대화로 전환합니다. DB에서 현재 메시지와 연결된 과거 대화 체인을 재귀적으로 탐색하여 AI가 이전 대화를 기억할 수 있도록 컨텍스트를 구성하여 전달합니다. `HISTORY_DEPTH_LIMIT` 상수를 통해 과거 기록의 무한 탐색을 방지하고 성능을 최적화합니다.

### 5.2. 명령어 계층 (Commands)

- **`BaseCommand`**: 모든 명령어의 근간이 되는 추상 클래스로, 메시지 전송 로직의 중추인 `reply` 메서드를 포함합니다. 텔레그램의 메시지 길이 제한(4,096자)을 넘는 긴 응답을 안전하게 분할하며, 이때 `<pre>`와 같은 HTML 태그가 중간에 끊기지 않도록 태그 밸런싱 로직을 수행합니다. 생성된 이미지를 원본 품질로 유지하기 위해 파일(Document) 형태로의 동시 전송 기능을 지원합니다.
- **`GenAICommand`**: AI 모델과의 인터랙션에 특화된 공통 클래스입니다. API 서버 장애(5xx) 시의 지수 백오프 기반 자동 재시도 로직(최대 3회), 구글 안전성 필터링(Safety Filter)에 의한 차단 처리 및 사용자 알림, 코드 실행 및 웹 검색 결과의 HTML 포맷팅을 담당합니다. `buildPrompt` 로직을 통해 앨범 메시지 내의 모든 미디어와 텍스트를 AI 모델이 이해 가능한 통합 `Content` 구조로 변환합니다.
- **개별 Command 클래스**: 각 명령어는 독립적인 클래스로 구현되어 보안 및 정확성을 위한 시스템 프롬프트를 개별 관리합니다. 예를 들어 `SummarizeCommand`는 명사형 종결 어미를 강제하는 GeekNews 스타일 가이드를, `MapCommand`는 Google Maps 도구 활성화 설정을 포함합니다.

### 5.3. 서비스 계층 (Services)

- **`db.ts`**: SQLite3를 사용하여 견고한 데이터 영속성을 제공합니다. `raw_messages` 테이블은 수신된 모든 JSON 전문을 기록하며, `attachments`와 `message_attachments`는 다중 미디어 파일을 체계적으로 연결합니다. 특히 `model_response_metadata` 테이블은 AI가 생성한 단순 텍스트뿐만 아니라 내부적인 '생각의 흐름(Parts)'까지 완벽하게 기록하여 추후 분석 및 대화 복원의 정확도를 보장합니다.
- **`auth.ts`**: 화이트리스트 기반의 2단계 인증 체계를 제공합니다. `config.ts`에 정의된 `TRUSTED_USER_IDS`(개인) 및 `ALLOWED_CHANNEL_IDS`(그룹/채널)를 실시간으로 대조하여 비인가 사용자의 접근을 원천 차단합니다.

### 5.4. 유틸리티 계층 (Helpers)

- **`utils.ts`**: 프로젝트 전반에서 사용되는 다양한 공통 함수를 제공합니다. `bot.getFileStream`으로 받은 파일 스트림을 `Buffer`로 변환하고, 메모리 캐시(`imageCache`)를 운영하여 동일 파일의 중복 다운로드를 방지합니다. 
- **콘텐츠 빌더 로직**: 대화 기록과 현재 메시지의 파일(이미지, PDF 등)을 취합하여 Gemini API가 요구하는 최종 `Content[]` 배열 형식을 구성합니다. 총 파일 크기가 100MB를 초과하는지 사전에 확인하여 오류를 방지합니다.

## 6. 안정성 및 최적화

- **지능형 타임아웃 제어:** AI 응답 지연에 따른 무한 대기를 방지하기 위해 `AbortSignal.timeout`을 도입했습니다. 모든 AI 요청에 대해 10분(600,000ms)의 하드 타임아웃을 설정하여, 비정상적인 지연 시 요청을 자동 취소하고 리소스를 즉시 회수합니다.
- **재시도 및 백오프 전략:** 일시적인 네트워크 순단이나 API 서버 과부하(500, 503 오류) 발생 시 즉시 실패 처리하지 않고 최대 3회까지 자동 재시도를 수행합니다. 시도 횟수에 비례하여 대기 시간을 늘려 서버의 부담을 최소화하는 지연 전략을 사용합니다.
- **리소스 제어 및 용량 관리:** 모델에 전송되는 총 아티팩트(이미지, 문서 등)의 합산 크기를 100MB로 엄격히 제한합니다. 이는 API 호출 실패를 사전에 방지하고 불필요한 대역폭 소모를 막습니다. 또한 자주 조회되는 이미지 데이터에 대해 LRU(Least Recently Used) 방식의 메모리 캐시를 운영하여 데이터베이스 부하를 줄입니다.
- **Grounding Metadata 정규화:** AI 모델이 응답에 포함시킨 검색 출처나 인용 정보(Grounding Metadata)를 사용자 친화적인 HTML 하이퍼링크 형식으로 변환하여 정보의 투명성을 높입니다.

## 7. 테스트 (Testing)

`Jest` 테스트 프레임워크를 기반으로 한 체계적인 검증 프로세스를 운영합니다:

- **단위 테스트 (Unit Testing):** 각 명령어 클래스의 독립적 로직, 매니저의 라우팅 규칙, DB 서비스의 쿼리 무결성, 유틸리티 함수의 정확성을 개별적으로 검증합니다.
- **통합 테스트 (Integration Testing):** 텔레그램 메시지 유입부터 명령어 식별, 세션 기록 로드, AI 모델 응답 생성, 최종 결과 전송까지 이어지는 전체 런타임 사이클의 정상 동작을 확인합니다.
- **철저한 모킹 전략 (Mocking):** 실제 네트워크 환경이나 API 키 유출 없이도 테스트가 가능하도록 `node-telegram-bot-api` 및 `@google/genai` SDK를 완벽하게 모킹하였습니다. 이를 통해 100% 예측 가능한 테스트 환경을 구축했습니다.
- **관리 효율성 극대화:** 각 컴포넌트별로 전용 테스트 파일을 운영하며, 서비스 테스트의 경우 일관성 있는 네이밍 규칙(예: `auth.test.ts`, `db.test.ts`)을 적용하여 유지보수 편의를 도모하였습니다.
