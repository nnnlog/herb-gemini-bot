# Gemini 텔레그램 봇 프로젝트 분석

## 1. 프로젝트 목적

이 프로젝트는 Google의 Gemini AI를 활용하여 사용자의 프롬프트를 기반으로 텍스트 응답을 생성하고, 이미지를 생성하는 기능을 제공하는 텔레그램 봇입니다. 사용자는 간단한 명령어를 통해 AI와 상호작용할 수
있으며, 사진이나 텍스트 메시지에 답장하는 방식으로도 자연스러운 대화가 가능합니다. 봇은 대화의 맥락을 기억하여 연속적인 상호작용을 지원합니다.

## 2. 주요 기능

- **명령어 자동 등록:** 봇 시작 시 `commands.ts`에 정의된 명령어를 텔레그램에 자동으로 등록합니다. `showInList` 속성으로 명령어 메뉴 표시 여부를 제어하며, 별칭(alias)은 원본
  명령어와 함께 설명이 제공됩니다.
- **봇 지정 명령어 처리:** 그룹 채팅 등에서 `/명령어@봇이름` 형식으로 명령이 들어올 경우, 자신의 사용자명과 일치할 때만 응답하여 다른 봇과의 혼선을 방지합니다.
- **봇 시작 및 도움말:** 봇을 시작하고 사용 가능한 명령어 목록을 안내합니다. (`/start` 명령어, 목록에는 표시되지 않음)
- **텍스트 생성:** 사용자가 입력한 프롬프트에 대해 Gemini AI가 생성한 텍스트 응답을 제공합니다. (`/gemini`, `/g` 별칭)
- **지도 기반 대화:** Google 지도 기능이 활성화된 상태로 Gemini AI와 대화합니다. (`/map` 명령어)
- **이미지 생성:** 사용자가 입력한 프롬프트를 기반으로 이미지를 생성합니다. (`/image`, `/img` 별칭)
- **내용 요약:** 사용자가 제공한 텍스트나 대화 내용을 요약합니다. (`/summarize` 명령어)
- **대화형 응답:** 사용자가 봇의 메시지에 답장하면, 이전 대화의 맥락을 기억하여 자연스러운 대화를 이어갑니다.
- **미디어 처리:** 사용자가 전송한 사진이나 앨범(여러 사진)을 이해하고, 이를 기반으로 명령을 수행할 수 있습니다.
- **대화 기록:** 모든 상호작용은 SQLite 데이터베이스에 기록되어 대화의 연속성을 유지합니다.
- **사용자 인증:** 설정 파일에 정의된 사용자 및 채널만 봇을 사용할 수 있도록 제한합니다.

## 3. 사용된 주요 기술

- **언어:** TypeScript
- **런타임:** Node.js
- **텔레그램 봇 API:** `node-telegram-bot-api`
- **Google AI:** `@google/genai`
- **데이터베이스:** `sqlite3`, `db-migrate`
- **테스트:** Jest
- **기타:** `dotenv` (환경 변수), `marked` (마크다운 파싱)

## 4. 프로젝트 구조

```
.
├── dist/                     # 컴파일된 JavaScript 파일
├── node_modules/             # Node.js 모듈
├── src/                      # 소스 코드 디렉토리
│   ├── bot.ts                # 봇의 메인 진입점
│   ├── config.ts             # 환경 변수 및 설정 관리
│   ├── types.ts              # 프로젝트 전역 타입 정의
│   ├── commands.ts           # 모든 명령어의 정의와 속성 관리
│   ├── handlers/             # 메시지 및 명령어 처리 로직
│   │   ├── commandRouter.ts      # 사용자 의도 파악 및 명령어 라우팅
│   │   ├── mediaGroupHandler.ts  # 앨범(미디어 그룹) 메시지 처리
│   │   ├── startCommandHandler.ts  # /start 명령어 처리
│   │   ├── chatCommandHandler.ts # /gemini (텍스트 생성) 명령어 처리
│   │   ├── imageCommandHandler.ts# /image (이미지 생성) 명령어 처리
│   │   ├── mapCommandHandler.ts    # /map (지도 기반 대화) 명령어 처리
│   │   └── summarizeCommandHandler.ts# /summarize (내용 요약) 명령어 처리
│   ├── services/             # 외부 서비스 연동 및 핵심 비즈니스 로직
│   │   ├── aiHandler.ts        # Google Gemini API 연동 관리
│   │   ├── auth.ts             # 사용자 권한 인증
│   │   └── db.ts               # SQLite 데이터베이스 관리
│   └── helpers/              # 보조 유틸리티 함수
│       ├── commandHelper.ts    # 명령어 처리에 필요한 공통 준비 작업
│       └── utils.ts            # 파일 처리, 메시지 분할 등 공통 유틸리티
├── tests/                    # 테스트 코드
├── .gitignore                # Git 추적 제외 파일 목록
├── Dockerfile                # Docker 이미지 생성을 위한 설정 파일
├── jest.config.cjs           # Jest 테스트 프레임워크 설정
├── package.json              # 프로젝트 의존성 및 스크립트 관리
├── pnpm-lock.yaml            # pnpm 의존성 잠금 파일
├── telegram_log.db           # 메시지 기록이 저장되는 SQLite 데이터베이스 파일
└── tsconfig.json             # TypeScript 컴파일러 설정
```

## 5. 상세 분석

### 5.1. `src/` - 핵심 소스 코드

#### `bot.ts` (메인 진입점)

- 텔레그램 봇 인스턴스를 생성하고 폴링을 시작하여 메시지를 수신합니다.
- 봇 시작 시 `getMe()` API를 호출하여 자신의 ID와 사용자명(`username`)을 가져옵니다. 이 정보는 이후 명령어 처리 시 자신을 대상으로 하는 명령인지 확인하는 데 사용됩니다.
- 봇이 시작될 때 `commands.ts`의 명령어 목록을 `setMyCommands` API를 통해 텔레그램에 등록합니다. 이 때 `showInList` 속성이 `true`인 명령어만 등록 대상이 되며, 별칭(
  alias)의 경우 원본 명령어를 가리키는 설명이 동적으로 생성됩니다. (예: `'/gemini'의 별칭. ...`)
- 수신된 모든 메시지를 `mediaGroupHandler`로 전달하여 본격적인 처리를 위임합니다.

#### `config.ts` (설정 관리자)

- `dotenv`를 사용하여 `.env` 파일에서 환경 변수(API 키, 사용자 ID 등)를 로드합니다.
- 프로젝트 전역에서 사용될 설정 객체(`config`)를 생성하고 내보냅니다.
- 필수 환경 변수가 누락되었을 경우 프로세스를 중단시켜 오류를 방지합니다.

#### `types.ts` (타입 정의)

- 프로젝트 전반에서 사용되는 `Command`, `CommandHandler`와 같은 핵심 타입을 정의합니다.
- `Command` 인터페이스는 `showInList`라는 선택적(optional) boolean 속성을 포함하며, 이를 통해 해당 명령어를 텔레그램의 공식 명령어 목록에 표시할지 여부를 제어합니다.
- 타입 정의를 중앙에서 관리하여 코드의 일관성과 유지보수성을 높입니다.

#### `commands.ts` (명령어 정의)

- 봇에서 사용하는 모든 명령어를 중앙에서 정의하고 관리합니다.
- 각 명령어는 타입(`type`), 핸들러(`handler`), 설명(`description`), 별칭(`aliases`), 그리고 명령어 목록 표시 여부를 결정하는 `showInList` 속성을 포함하는 객체로
  구성됩니다.
- 이 정보를 바탕으로 `commandMap`을 생성하여 `commandRouter`에서 명령어 조회를 빠르게 수행할 수 있도록 합니다.
- 이 구조는 새로운 명령어의 추가 및 수정 시 라우팅 로직의 변경을 최소화하여 확장성을 높입니다.

### 5.2. `src/handlers/` - 명령어 및 메시지 핸들러

#### `mediaGroupHandler.ts`

- 사용자가 여러 장의 사진(앨범)을 한 번에 보냈을 때, 이를 단일 요청으로 처리하기 위한 로직을 담당합니다.
- `media_group_id`를 기준으로 짧은 시간 내에 들어온 메시지들을 캐싱하고, 타이머를 이용해 그룹화합니다.
- 그룹화가 완료되면 `commandRouter`로 메시지를 전달합니다. 미디어 그룹이 아닌 단일 메시지는 즉시 라우터로 전달됩니다.

#### `commandRouter.ts`

- 봇의 핵심 두뇌 역할을 하며, 사용자의 메시지를 분석하여 의도를 파악하고 적절한 핸들러로 분기합니다.
- **사용자 인증:** `auth.ts`를 통해 메시지를 보낸 사용자가 허가된 사용자인지 확인합니다.
- **명령어 결정:**
    - `commands.ts`에 정의된 `commandMap`을 사용하여 명시적 명령어(`/gemini`, `/image` 등)를 효율적으로 조회합니다.
    - **봇 지정 명령어 처리:** 사용자가 `/명령어@봇이름` 형식으로 명령을 내릴 경우, `@` 뒤의 봇이름이 현재 실행 중인 봇 자신의 사용자명과 일치하는지 확인합니다. 일치하지 않으면 해당 명령을
      무시하여, 여러 봇이 있는 대화방에서 의도치 않은 동작을 방지합니다.
    - 텍스트가 명령어로 시작하지 않는 경우, 봇의 메시지에 대한 답장인지를 확인하여 대화의 연속성(암시적 명령어)을 판단합니다. (`/gemini`, `/map`, `/summarize` 등)
- **프롬프트 유효성 검사:** 명령어만 있고 내용이 없는 경우, 또는 봇의 응답에 부적절하게 명령어로 답장하는 경우 등 잘못된 요청을 필터링합니다.
- **프롬프트 소스 결정:** 명령어만으로 답장한 경우, 원본 메시지를 프롬프트의 소스로 사용하는 등 실제 처리할 내용을 결정합니다.
- 분석된 결과에 따라 `commands.ts`에 등록된 적절한 핸들러 함수를 동적으로 호출합니다.

#### `startCommandHandler.ts`

- `/start` 명령어를 처리합니다.
- `commands.ts`에 정의된 명령어 목록을 동적으로 읽어와 환영 메시지와 함께 사용 가능한 명령어 목록을 생성하여 사용자에게 보여줍니다. 이를 통해 도움말이 항상 최신 상태를 유지하도록 보장합니다.

#### `chatCommandHandler.ts`

- `/gemini` 명령어 및 텍스트 기반 대화 생성을 처리합니다.
- `commandHelper`를 사용해 대화 기록과 현재 메시지를 AI 모델이 이해할 수 있는 형식으로 준비합니다.
- `aiHandler`를 호출하여 Gemini Pro 모델에 텍스트 생성을 요청합니다.
- 모델의 응답(텍스트, 코드 블록, 웹 검색 결과 등)을 HTML로 파싱하고 `utils.ts`의 `sendLongMessage`를 통해 사용자에게 전송합니다.

#### `imageCommandHandler.ts`

- `/image` 명령어 및 이미지 생성 관련 대화를 처리합니다.
- `commandHelper`를 통해 프롬프트와 컨텍스트(첨부 이미지 등)를 준비합니다.
- `aiHandler`를 호출하여 이미지 생성 모델에 요청을 보냅니다.
- 생성된 이미지를 버퍼 형태로 받아 텔레그램 `sendPhoto` 또는 `sendMediaGroup` API를 사용해 사용자에게 전송합니다. 텍스트 응답이 함께 생성된 경우 캡션으로 추가합니다.

#### `mapCommandHandler.ts`

- `/map` 명령어 및 지도 관련 대화를 처리합니다.
- `chatCommandHandler`와 거의 동일한 구조를 가지지만, Gemini API 요청 시 `codeExecution` 도구 대신 `googleMaps` 도구를 활성화하여 지도 관련 질문에 더 효과적으로 답변할 수 있도록 합니다.
- API 요청, 결과 처리, 오류 핸들링 등에서 다른 명령어 핸들러와 일관성을 유지합니다.

#### `summarizeCommandHandler.ts`

- `/summarize` 명령어를 처리하여 사용자가 제공한 콘텐츠(텍스트 등)를 요약합니다.
- 특정 시스템 프롬프트를 사용하여 'GeekNews' 스타일의 요약문을 생성하도록 유도합니다.
- `chatCommandHandler`와 거의 동일한 구조를 가지며, API 요청 방식, 결과 처리, 오류 핸들링 등에서 일관성을 유지합니다.

### 5.3. `src/services/` - 외부 연동 및 비즈니스 로직

#### `db.ts`

- `sqlite3` 라이브러리를 사용하여 로컬 데이터베이스(`telegram_log.db`)와의 모든 상호작용을 관리합니다.
- **스키마 정의:** 메시지, 첨부파일, 메타데이터 등을 저장하기 위한 테이블 구조를 정의하고 초기화합니다.
- **메시지 로깅:** 수신 및 발신되는 모든 메시지의 원본 JSON과 관련 정보를 DB에 저장합니다.
- **대화 기록 조회:** 특정 메시지에 대한 응답 체인을 재귀적으로 탐색하여 AI 모델에 컨텍스트로 제공할 대화 기록(`ConversationTurn[]`)을 생성하는 핵심 기능을 수행합니다.

#### `auth.ts`

- 간단한 사용자 인증 로직을 제공합니다.
- `config.ts`에 정의된 `trustedUserIds` (사용자 ID 목록)와 `allowedChannelIds` (채널 ID 목록)를 기반으로 현재 요청이 유효한지 검사합니다.

#### `aiHandler.ts`

- Google Gemini API와의 통신을 추상화한 모듈입니다.
- `@google/genai` SDK를 사용하여 콘텐츠 생성 요청을 보냅니다.
- **오류 처리 및 재시도:** API에서 5xx 오류(서버 과부하 등)가 발생했을 때, 지연 시간을 두고 몇 차례 재시도하는 로직이 구현되어 있습니다.
- **안전성 검사:** API 응답이 Google의 안전 정책에 의해 차단되었는지 확인하고, 그에 맞는 오류 메시지를 반환합니다.
- **응답 파싱:** API 응답에서 텍스트, 이미지, 메타데이터 등을 추출하여 일관된 `GenerationOutput` 객체로 정규화하여 반환합니다.

### 5.4. `src/helpers/` - 보조 유틸리티

#### `utils.ts`

- 프로젝트 전반에서 사용되는 다양한 공통 함수를 제공합니다.
- **파일 처리:** `bot.getFileStream`으로 받은 파일 스트림을 `Buffer`로 변환하고, 메모리 캐시(`imageCache`)를 운영하여 동일 파일의 중복 다운로드를 방지합니다.
- **콘텐츠 빌더 (`buildContents`):** `db.ts`에서 가져온 대화 기록과 현재 메시지의 파일들을 취합하여 Gemini API가 요구하는 최종 `Content[]` 배열 형식으로 구성합니다.
- **메시지 분할 (`sendLongMessage`):** 텔레그램의 메시지 최대 길이(4096자)를 초과하는 긴 응답을 코드 블록(`\n<pre>`) 등을 고려하여 여러 개의 메시지로 안전하게 분할하여 순차적으로
  전송합니다.

#### `commandHelper.ts`

- 명령어 핸들러들의 공통 준비 작업을 돕는 함수를 제공합니다.
- **콘텐츠 준비 (`prepareContentForModel`):** 명령어 실행에 앞서 대화 기록을 가져오고, `utils.ts`의 `buildContents`를 호출하여 모델에 보낼 콘텐츠를 생성합니다. 이
  과정에서 총 파일 크기가 제한을 초과하는지 검사합니다.
- **오류 핸들러 (`handleCommandError`):** 각 명령어 핸들러의 `try...catch` 블록에서 예외 발생 시 호출되어, 오류를 콘솔에 로깅하고 사용자에게 일관된 오류 메시지를 보내는 역할을
  합니다.

## 6. @tests - 테스트

이 프로젝트는 `Jest`를 테스트 프레임워크로 사용하여 코드의 안정성과 신뢰성을 확보합니다. 단위 테스트와 통합 테스트를 통해 핵심 로직이 예상대로 동작하는지 검증합니다.

### 6.1. 테스트 전략

- **의존성 모킹(Mocking):** `node-telegram-bot-api`, `@google/genai`, `sqlite3`와 같은 외부 라이브러리와의 의존성을 `jest.mock`을 사용하여 가상으로
  구현합니다. 이를 통해 각 테스트 단위를 외부 환경의 영향 없이 독립적으로 검증할 수 있습니다.
- **계층별 테스트:** `services`, `handlers`, `helpers` 등 각 모듈의 역할에 맞춰 테스트를 구성하여 특정 기능의 동작을 정밀하게 확인할 수 있습니다.

### 6.2. 테스트 구조

`tests/` 디렉토리는 `src/` 디렉토리의 구조를 그대로 반영하여 테스트 파일과 소스 코드 간의 연관성을 쉽게 파악할 수 있도록 구성되어 있습니다.

- `tests/services/`: `db.service.test.ts`, `auth.service.test.ts`, `aiHandler.service.test.ts` 등 서비스 계층의 비즈니스 로직을
  테스트합니다.
- `tests/handlers/`: `commandRouter.handler.test.ts`, `mediaGroupHandler.handler.test.ts` 등 사용자의 입력을 처리하고 라우팅하는 핸들러의 동작을
  검증합니다.
- `tests/helpers/`: `utils.helper.test.ts`와 같이 프로젝트 전반에서 사용되는 유틸리티 함수의 정확성을 테스트합니다.

### 6.3. 주요 테스트 영역

- **AI 핸들러 (`aiHandler.service.test.ts`):** Gemini API 호출 시 발생할 수 있는 네트워크 오류, API의 안전성 설정에 의한 차단 등 다양한 예외 상황에 대한 재시도 및
  오류 처리 로직을 중점적으로 검증합니다.
- **명령어 라우터 (`commandRouter.handler.test.ts`):** 사용자의 메시지(텍스트, 답장, 미디어 등)가 새로운 `commandMap` 구조에 따라 정확한 명령어 핸들러(`/gemini`, `/image`, `/map` 등)로 분기되는지,
  잘못된 프롬프트는 올바르게 거절되는지, 대화 연속성이 잘 동작하는지를 테스트합니다.
- **데이터베이스 서비스 (`db.service.test.ts`):** 대화 기록을 조회하고, AI 모델이 요구하는 형식(`ConversationTurn[]`)으로 정확하게 가공하는 로직을 집중적으로 테스트합니다.
